<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
        对象（object）：everything is object，一切皆对象
        只要你关心他、研究他，不管是抽象的还是具体的事物，都是对象
        面向对象（object-oriented）
        OOA：面向对象分析
        OOD：面向对象设计
        OOP：面向对象编程
     -->
     <!-- 
         人到图书馆借书
         对象：
            人：
                属性：姓名、身份证
            
            图书馆：
                属性：馆名、地址
            
            书：
                属性：书名、ISBN
            
            管理员：
                属性：
                方法：登记（）

      -->

      <script>
        //   定义对象的几种方式
        // 第一种:new Object()
        var o1 = new Object();
        // console.log(o1);   //{}
        //定义属性
        o1.name = 'lisi';
        o1.age = 23;
        //定义方法
        o1.sayHello = function(){
            console.log('hhhhh');
        };

        //第二种：使用对象直接量(literal)
        var o2 = {
            name: 'lisi',
            age: 23,
            sayHello:function(){
                console.log('hheheheh....');
            }
        };


        //第三种：Object.create()
        // var o3 = Object.create(o1);//o3 基于o1创建的，继承了o1的属性和方法
        //o1 与 o3 是否一样？？  答案是不一样！
        //              两种坑：第一是o1 == o3:？。第二：形式上是否相等？ 
        // o3.gender = 'male';
        // o3.name = 'wangwu';
        // console.log(o3.name);//wangwu
        // o1.name = 'zhaoliu';
        // o3.name = 'wangwu';
        // o1.name = 'tianqi';
        // console.log(o3.name);//先找自有的属性，有就取出。在找父类属性
        // console.log(o1); //{name: 'lisi', age: 23, sayHello: ƒ}
        // console.log(o3);//{}

        // console.log(o1 == o3);//false
        // console.log(o3.name, o3.age);//lisi 23

        //Object.create()方法创建一个新对象(o3)，使用现有的对象(o1)来提供新创建的对象的__proto__既：o3.__proto__ = o1;
        var o3 = Object.create(o1);
        // o3.__proto__ = o1;//前面有_的是代表私有属性，别碰
        // var o4 = new Object();
        // o4.name = "zhangsan";
        // o4._gender = 'male';


        // //.....

        // o4.name = 'lisi';
        // o4._gender = ' female'; //=> 这么做是错误的，约定上是私有的，千万不能碰
        // var o4 = o1;
        // console.log(o3);//{}
        // console.log(o4);//{name: 'lisi', age: 23, sayHello: ƒ}

        //第四种：new class
        //es6 版本开始使用这种定义法
        // class Person{
        //     constructor(name,age){
        //         this.name = name;
        //         this.age = age;
        //     }
        // }
        // var p = new Person('lisi',23);
        // console.log(p.name,p.age);

        //es5-
        //定义类
        // function Person(name,age){
        //     this.name = name;
        //     this.age = age;
        //     this.sayHello = function(){
        //         console.log('My name is '+this.name + ',my age is '+ this.age + ', hello!');
        //     }//底层原理：this.sayHello = new Function();所以每次创建实例对象都会new一次，但sayHello方法中
            //的内容都是一样的，就会浪费内存空间，不是很有必要，没必要重复出现，这就是问题所在。
        // }
        //解决方法一（不推荐）：将类中的方法提出，
        // var fn = function(){
        //     console.log('My name is '+this.name + ',my age is '+ this.age + ', hello!');
        // }

        // function Person(name,age){
        //     this.name = name;
        //     this.age = age;
        //     this.sayHello = fn;
        // }

        //解决方法二（最佳）：
        //约定：方法放在类的原型中
        //      属性放在构造函数中
        function Person(name,age){
            this.name = name;
            this.age = age;
        }
        Person.prototype.sayHello = function(){  //原型
            console.log('My name is '+this.name + ',my age is '+ this.age + ', hello!');
        }


        //创建类的实例对象
        var p1 = new Person('lisi',34);
        console.log(p1);//Person {name: 'lisi', age: 23}
        // p1.sayHello();
        // var p2 = new Person('wangwu',24);
        // console.log(p2);
        //this是指对当前对象的引用
      </script>
</body>
</html>