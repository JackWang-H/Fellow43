<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1 id="h11">这是一个h1</h1>
    <p>这是一个p</p>
    <div id="div1">
        123456
        <h1 id="h12">这是H12</h1>
        <p id="p2">这是p2</p>
    </div>
    <script>
        var oH1 = document.getElementById('h11');
        var oP2 = document.getElementById('p2');
        //1:兄弟  nextSibling  | nextElementSibling
        // console.log(oH1.nextSibling);   //下一个兄弟，此方法不会忽略回车等文本
        // console.log(oH1.nextElementSibling);//IE8及以前都不支持,存在兼容性问题

        //封装next方法，在所有浏览器中都可以返回下一个兄弟元素节点
        function next(elem){
            do{
                elem = elem.nextSibling;
            }while(elem && elem.nodeType != 1);
            return elem;
        }

        // console.log(next(oH1));
        next(oH1).style.background = 'red';
        // next(oP2).style.background = 'red';

        //1. 孩子 firstChild   |  firstElementChild
        var oDiv1 = document.getElementById('div1');
        // console.log(oDiv1.firstChild);
        // console.log(oDiv1.firstElementChild);
        //两者存在问题与上面类似
        //封装first方法，在所有浏览器中都可以返回第一个元素孩子节点
        function first(elem){
            elem = elem.firstChild;
            return elem && elem.nodeType != 1 ? next(elem) : elem;
        }

        first(oDiv1).style.background = 'red';
    </script>
</body>
</html>